trigger:
  branches:
    include:
      - main

pool:
  name: 'Default'
  demands:
    - Agent.Name -equals agent-sensipro

variables:
  - group: lms-secrets
  - name: dockerRegistryServiceConnection
    value: sensiProACRConnection
  - name: kubernetesServiceConnection
    value: sensiProAKSConnection
  - name: containerRegistry
    value: sensiproacr.azurecr.io
  - name: imageTag
    value: $(Build.BuildId)

stages:
- stage: Build
  displayName: 'Build and Push Images'
  jobs:
  - job: BuildAndPush
    displayName: 'Build and Push all microservices'
    steps:
    - checkout: self

    # Connexion √† ACR
    - task: Docker@2
      displayName: 'Login to ACR'
      inputs:
        command: 'login'
        containerRegistry: '$(dockerRegistryServiceConnection)'

    # V√©rifier la structure du projet
    - task: PowerShell@2
      displayName: 'Check project structure'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "=== Project Structure Check ==="
          Get-ChildItem -Recurse -Depth 2 | Where-Object { $_.PSIsContainer } | ForEach-Object {
            Write-Host "Directory: $($_.FullName)"
          }
          
          # V√©rifier les Dockerfiles
          $dockerfiles = Get-ChildItem -Recurse -Name "Dockerfile*"
          Write-Host "=== Found Dockerfiles ==="
          $dockerfiles | ForEach-Object { Write-Host "Dockerfile: $_" }

    # Build et push des microservices (version corrig√©e)
    - task: PowerShell@2
      displayName: 'Build and push all microservices'
      inputs:
        targetType: 'inline'
        script: |
          # Configuration PowerShell pour une meilleure gestion des erreurs
          $ErrorActionPreference = "Stop"
          $ProgressPreference = "SilentlyContinue"
          
          # V√©rification et d√©finition explicite des variables
          $containerRegistry = $env:containerRegistry
          $imageTag = $env:imageTag
          
          if ([string]::IsNullOrEmpty($containerRegistry)) {
              Write-Error "‚ùå La variable containerRegistry est vide ou non d√©finie !"
              exit 1
          }
          
          if ([string]::IsNullOrEmpty($imageTag)) {
              Write-Error "‚ùå La variable imageTag est vide ou non d√©finie !"
              exit 1
          }

          Write-Host "DEBUG - containerRegistry: $containerRegistry"
          Write-Host "DEBUG - imageTag: $imageTag"

          # Dictionnaire microservice => chemin
          $services = @{
              "api-gateway"     = "Server/src/api-gateway"
              "auth-service"    = "Server/src/auth-service"
              "user-service"    = "Server/src/user-service"
              "payment-service" = "Server/src/payment-service"
              "course-service"  = "Server/src/course-service"
              "client"          = "Client"
          }

          $builtAny = $false

          foreach ($dir in $services.Keys) {
              $fullPath = $services[$dir]

              Write-Host "=== Checking directory: $fullPath ==="
              if (-Not (Test-Path $fullPath)) {
                  Write-Warning "‚ö†Ô∏è Directory not found: $fullPath. Skipping $dir..."
                  continue
              }

              # V√©rifier la pr√©sence du Dockerfile
              $dockerfilePath = Join-Path $fullPath "Dockerfile"
              if (-Not (Test-Path $dockerfilePath)) {
                  Write-Warning "‚ö†Ô∏è Dockerfile not found in $fullPath. Skipping $dir..."
                  continue
              }

              $dirLower = $dir.ToLower()
              $imageTagFull = "$containerRegistry/$dirLower`:$imageTag"
              $imageLatest = "$containerRegistry/$dirLower`:latest"

              Write-Host "=== Building ${dir} image from ${fullPath} ==="
              Write-Host "Image tags: $imageTagFull, $imageLatest"
              
              try {
                  # Build de l'image avec gestion d'erreur am√©lior√©e
                  Write-Host "Executing: docker build -t $imageTagFull -t $imageLatest $fullPath"
                  
                  # Utiliser Start-Process pour une meilleure gestion des erreurs
                  $process = Start-Process -FilePath "docker" -ArgumentList @("build", "-t", $imageTagFull, "-t", $imageLatest, $fullPath) -Wait -PassThru -NoNewWindow -RedirectStandardOutput "docker_output.txt" -RedirectStandardError "docker_error.txt"
                  
                  # Afficher les logs
                  if (Test-Path "docker_output.txt") {
                      Get-Content "docker_output.txt" | ForEach-Object { Write-Host $_ }
                      Remove-Item "docker_output.txt" -ErrorAction SilentlyContinue
                  }
                  
                  if (Test-Path "docker_error.txt") {
                      Get-Content "docker_error.txt" | ForEach-Object { Write-Host $_ }
                      Remove-Item "docker_error.txt" -ErrorAction SilentlyContinue
                  }
                  
                  if ($process.ExitCode -ne 0) {
                      Write-Error "‚ùå Build failed for $dir with exit code $($process.ExitCode)"
                      exit $process.ExitCode
                  }

                  # Push des images
                  Write-Host "Pushing $imageTagFull..."
                  $pushProcess = Start-Process -FilePath "docker" -ArgumentList @("push", $imageTagFull) -Wait -PassThru -NoNewWindow
                  if ($pushProcess.ExitCode -ne 0) {
                      Write-Error "‚ùå Push failed for $imageTagFull"
                      exit $pushProcess.ExitCode
                  }

                  Write-Host "Pushing $imageLatest..."
                  $pushLatestProcess = Start-Process -FilePath "docker" -ArgumentList @("push", $imageLatest) -Wait -PassThru -NoNewWindow
                  if ($pushLatestProcess.ExitCode -ne 0) {
                      Write-Error "‚ùå Push failed for $imageLatest"
                      exit $pushLatestProcess.ExitCode
                  }

                  Write-Host "‚úÖ Successfully built and pushed $dir"
                  $builtAny = $true
              }
              catch {
                  Write-Error "‚ùå Exception during build/push for ${dir}: $($_.Exception.Message)"
                  exit 1
              }
          }

          if (-Not $builtAny) {
              Write-Error "‚ùå Aucun microservice n'a √©t√© build√© !"
              exit 1
          }

          Write-Host "üéâ All microservices built and pushed successfully!"
      env:
        containerRegistry: $(containerRegistry)
        imageTag: $(imageTag)

    # Alternative: Build individuel pour chaque service (plus robuste)
    - task: Docker@2
      displayName: 'Build API Gateway'
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: 'api-gateway'
        command: 'buildAndPush'
        Dockerfile: 'Server/src/api-gateway/Dockerfile'
        buildContext: 'Server/src/api-gateway'
        tags: |
          $(imageTag)
          latest

    - task: Docker@2
      displayName: 'Build Auth Service'
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: 'auth-service'
        command: 'buildAndPush'
        Dockerfile: 'Server/src/auth-service/Dockerfile'
        buildContext: 'Server/src/auth-service'
        tags: |
          $(imageTag)
          latest

    - task: Docker@2
      displayName: 'Build User Service'
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: 'user-service'
        command: 'buildAndPush'
        Dockerfile: 'Server/src/user-service/Dockerfile'
        buildContext: 'Server/src/user-service'
        tags: |
          $(imageTag)
          latest

    - task: Docker@2
      displayName: 'Build Course Service'
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: 'course-service'
        command: 'buildAndPush'
        Dockerfile: 'Server/src/course-service/Dockerfile'
        buildContext: 'Server/src/course-service'
        tags: |
          $(imageTag)
          latest

    - task: Docker@2
      displayName: 'Build Payment Service'
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: 'payment-service'
        command: 'buildAndPush'
        Dockerfile: 'Server/src/payment-service/Dockerfile'
        buildContext: 'Server/src/payment-service'
        tags: |
          $(imageTag)
          latest

    - task: Docker@2
      displayName: 'Build Client'
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: 'client'
        command: 'buildAndPush'
        Dockerfile: 'Client/Dockerfile'
        buildContext: 'Client'
        tags: |
          $(imageTag)
          latest

    # Scan de s√©curit√© optionnel
    - task: Bash@3
      displayName: 'Security scan with Trivy'
      condition: false  # D√©sactiv√© temporairement
      inputs:
        targetType: 'inline'
        script: |
          echo "Installing Trivy..."
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b .
          ./trivy --version

          services=("api-gateway" "auth-service" "user-service" "payment-service" "course-service" "client")
          for dir in "${services[@]}"; do
            dirLower=$(echo "$dir" | tr '[:upper:]' '[:lower:]')
            imageTag="${containerRegistry}/${dirLower}:${imageTag}"
            
            echo "=== Scanning ${dir} image with Trivy ==="
            ./trivy image --exit-code 0 --severity HIGH,CRITICAL "$imageTag" || true
          done
      env:
        containerRegistry: $(containerRegistry)
        imageTag: $(imageTag)
      continueOnError: true

- stage: Deploy
  displayName: 'Deploy to AKS'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - deployment: DeployToAKS
    displayName: 'Deploy all microservices to AKS'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          
          # Cr√©er les namespaces s'ils n'existent pas
          - task: Kubernetes@1
            displayName: 'Create namespaces'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'apply'
              arguments: '-f k8s/namespaces.yaml'
            continueOnError: true

          # Appliquer les secrets
          - task: Kubernetes@1
            displayName: 'Apply secrets'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'apply'
              arguments: '-f k8s/secrets.yaml'
            continueOnError: true

          # Mettre √† jour les images dans les d√©ploiements
          - task: Kubernetes@1
            displayName: 'Update image tags in deployments'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'patch'
              arguments: 'deployment api-gateway -p "{\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"name\":\"api-gateway\",\"image\":\"$(containerRegistry)/api-gateway:$(imageTag)\"}]}}}}"'

          # D√©ployer tous les services
          - task: Kubernetes@1
            displayName: 'Deploy all services'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'apply'
              arguments: '-f k8s/'

          # V√©rifier le statut des d√©ploiements
          - task: Kubernetes@1
            displayName: 'Check deployment status'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'get'
              arguments: 'pods --all-namespaces -l app in (api-gateway,auth-service,user-service,course-service,payment-service,frontend)'

          # Attendre que les d√©ploiements soient pr√™ts
          - task: Kubernetes@1
            displayName: 'Wait for deployments to be ready'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'wait'
              arguments: '--for=condition=available --timeout=300s deployment --all'