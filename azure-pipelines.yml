trigger:
  branches:
    include:
      - main

pool:
  name: 'Default'
  demands:
    - Agent.Name -equals agent-sensipro

variables:
  - group: lms-secrets
  - name: dockerRegistryServiceConnection
    value: sensiProACRConnection
  - name: kubernetesServiceConnection
    value: sensiProAKSConnection
  - name: containerRegistry
    value: sensiproacr.azurecr.io
  - name: imageTag
    value: $(Build.BuildId)

stages:
- stage: Build
  displayName: 'Build and Push Images'
  jobs:
  - job: BuildAndPush
    displayName: 'Build and Push all microservices'
    steps:
    - checkout: self

    # Connexion √† ACR
    - task: Docker@2
      displayName: 'Login to ACR'
      inputs:
        command: 'login'
        containerRegistry: '$(dockerRegistryServiceConnection)'

    # Build et push des microservices
    - task: PowerShell@2
      displayName: 'Build and push all microservices'
      inputs:
        targetType: 'inline'
        script: |
          # V√©rification et d√©finition explicite des variables
          $containerRegistry = $env:containerRegistry
          $imageTag = $env:imageTag
          
          if ([string]::IsNullOrEmpty($containerRegistry)) {
              Write-Error "‚ùå La variable containerRegistry est vide ou non d√©finie !"
              exit 1
          }
          
          if ([string]::IsNullOrEmpty($imageTag)) {
              Write-Error "‚ùå La variable imageTag est vide ou non d√©finie !"
              exit 1
          }

          Write-Host "DEBUG - containerRegistry: $containerRegistry"
          Write-Host "DEBUG - imageTag: $imageTag"

          # Dictionnaire microservice => chemin
          $services = @{
              "api-gateway"     = "Server/src/api-gateway"
              "auth-service"    = "Server/src/auth-service"
              "user-service"    = "Server/src/user-service"
              "payment-service" = "Server/src/payment-service"
              "course-service"  = "Server/src/course-service"
              "client"          = "Client"
          }

          $builtAny = $false

          foreach ($dir in $services.Keys) {
              $fullPath = $services[$dir]

              if (-Not (Test-Path $fullPath)) {
                  Write-Warning "‚ö†Ô∏è Directory not found: $fullPath. Skipping $dir..."
                  continue
              }

              $dirLower = $dir.ToLower()
              $imageTagFull = "$containerRegistry/$dirLower`:$imageTag"
              $imageLatest = "$containerRegistry/$dirLower`:latest"

              Write-Host "=== Building and pushing ${dir} image from ${fullPath} ==="
              
              # Build de l'image avec logs d√©taill√©s
              Write-Host "Executing: docker build -t $imageTagFull -t $imageLatest $fullPath"
              docker build -t $imageTagFull -t $imageLatest $fullPath 2>&1 | ForEach-Object { Write-Host $_ }
              if ($LASTEXITCODE -ne 0) {
                  Write-Error "‚ùå Build failed for $dir. Check Dockerfile and logs above in $fullPath"
                  exit $LASTEXITCODE
              }

              # Push des images
              Write-Host "Pushing $imageTagFull..."
              docker push $imageTagFull
              if ($LASTEXITCODE -ne 0) {
                  Write-Error "‚ùå Push failed for $imageTagFull"
                  exit $LASTEXITCODE
              }

              Write-Host "Pushing $imageLatest..."
              docker push $imageLatest
              if ($LASTEXITCODE -ne 0) {
                  Write-Error "‚ùå Push failed for $imageLatest"
                  exit $LASTEXITCODE
              }

              Write-Host "‚úÖ Successfully built and pushed $dir"
              $builtAny = $true
          }

          if (-Not $builtAny) {
              Write-Error "‚ùå Aucun microservice n'a √©t√© build√© !"
              exit 1
          }

          Write-Host "üéâ All microservices built and pushed successfully!"
      env:
        containerRegistry: $(containerRegistry)
        imageTag: $(imageTag)

    # Scan des images avec Trivy (optionnel - vous pouvez commenter cette section)
    - task: Bash@3
      displayName: 'Security scan with Trivy'
      inputs:
        targetType: 'inline'
        script: |
          echo "Installing Trivy..."
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b .
          ./trivy --version

          services=("api-gateway" "auth-service" "user-service" "payment-service" "course-service" "client")
          for dir in "${services[@]}"; do
            dirLower=$(echo "$dir" | tr '[:upper:]' '[:lower:]')
            imageTag="${containerRegistry}/${dirLower}:${imageTag}"
            
            echo "=== Scanning ${dir} image with Trivy ==="
            ./trivy image --exit-code 0 --severity HIGH,CRITICAL "$imageTag" || true
          done
      env:
        containerRegistry: $(containerRegistry)
        imageTag: $(imageTag)
      continueOnError: true

- stage: Deploy
  displayName: 'Deploy to AKS'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - deployment: DeployToAKS
    displayName: 'Deploy all microservices to AKS'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          
          # Cr√©er les namespaces s'ils n'existent pas
          - task: Kubernetes@1
            displayName: 'Create namespaces'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'apply'
              arguments: '-f k8s/namespaces.yaml'
            continueOnError: true

          # Appliquer les secrets
          - task: Kubernetes@1
            displayName: 'Apply secrets'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'apply'
              arguments: '-f k8s/secrets.yaml'
            continueOnError: true

          # D√©ployer API Gateway
          - task: Kubernetes@1
            displayName: 'Deploy API Gateway'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'apply'
              arguments: '-f k8s/api-gateway-deployment.yaml -f k8s/api-gateway-service.yaml'

          # D√©ployer Auth Service
          - task: Kubernetes@1
            displayName: 'Deploy Auth Service'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'apply'
              arguments: '-f k8s/auth-service-deployment.yaml -f k8s/auth-service-service.yaml'

          # D√©ployer User Service
          - task: Kubernetes@1
            displayName: 'Deploy User Service'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'apply'
              arguments: '-f k8s/user-service-deployment.yaml -f k8s/user-service-service.yaml'

          # D√©ployer Course Service
          - task: Kubernetes@1
            displayName: 'Deploy Course Service'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'apply'
              arguments: '-f k8s/course-service-deployment.yaml -f k8s/course-service-service.yaml'

          # D√©ployer Payment Service
          - task: Kubernetes@1
            displayName: 'Deploy Payment Service'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'apply'
              arguments: '-f k8s/payment-service-deployment.yaml -f k8s/payment-service-service.yaml'

          # D√©ployer Frontend
          - task: Kubernetes@1
            displayName: 'Deploy Frontend'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'apply'
              arguments: '-f k8s/frontend-deployment.yaml -f k8s/frontend-service.yaml'

          # V√©rifier le statut des d√©ploiements
          - task: Kubernetes@1
            displayName: 'Check deployment status'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              command: 'get'
              arguments: 'pods --all-namespaces -l app in (api-gateway,auth-service,user-service,course-service,payment-service,frontend)'